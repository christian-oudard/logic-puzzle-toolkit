new puzzles:
- puzzles using square grid
  . kuromasu
  . mochikoro
  . bijutsukan
  . hitori
- puzzles using hex grid
- loop puzzles
  . slither link
- update Tritower.valid_tower_loops to handle arbitrary shapes

housekeeping:
- reduce duplication (last_conclusion, etc) in board.solve 
- refactor Board.set_number, it's only used once
- use dict.get where appropriate, instead of doing exception handling

solving:
- ABORT signal?
- track depth reached from solve(), not from the threads
  . use call stack?
- make solver able to handle a huge blank board
- test if board is already solved
  . audit how it's currently being checked for solution
  . branch finding solution when looking for contradiction
    . detect multiple solutions
- adjust priority function constants

gui:
- do square grid
  . move triangle or square grid display functions to new class
- solve puzzles interactively
- show slowed-down solving animation
- buttons and stuff
  . "attempt to solve" button
  . check box for whether to immediately show invalid
- localized invalidity display

optimization:
- branch-merge 
  . when opposing (black / white) solution branches reach common conclusions, it must be true
- instead of copying whole board, create an overlay dictionary which only has the values of changed cells
	- possibly use dict.update() to propagate changes
- perhaps track positions that may duplicate each other, and detect transitions where 2 threads get to the same board

nurikabe 
    def valid_white_reachable(self):
        for pos_white in self.white_positions:
            for pos_given in self.given_positions:
                number = self[pos]
                if number not in GIVENS:
                    continue
                if manhattan_distance(pos_given, pos_white) < number:
					...

def manhattan_distance(pos1, pos2):
    x1, y1 = pos1
    x2, y2 = pos2
    return abs(x2 - x1) + abs(y2 - y1)
