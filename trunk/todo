features:
- optimal solution path
	- what is the assumption path that requires the fewest validity checks?
	- this might require slower solving which parallelizes solution threads

nurikabe:
- orphan groups reaching validation to check the number as well. this will supersede the reachability check.
new puzzles:
- puzzles using square grid
  . kuromasu
  . mochikoro
  . bijutsukan
  . hitori
- puzzles using hex grid
- loop puzzles
  . slither link
- update Tritower.valid_tower_loops to handle arbitrary shapes

housekeeping:
- reduce duplication of x = x * 2 + 1 and x = x // 2 - 1


solving:
- ABORT signal?
- track depth reached from solve(), not from the threads
  . use call stack?
- make solver able to handle a huge blank board
- test if board is already solved
  . audit how it's currently being checked for solution
  . branch finding solution when looking for contradiction
    . detect multiple solutions

gui:
- human-guided computer solving
	- computer does what it can, at full speed
	- as the human sees a possible conclusion, he marks it
	- computer verifies it
- do square grid
  . move triangle or square grid display functions to new class
- solve puzzles interactively
- show slowed-down solving animation
- buttons and stuff
  . "attempt to solve" button
  . check box for whether to immediately show invalid
- localized invalidity display

optimization:
- spaces which yield 0-length assumption threads get prioritized down for future conclusion threads
- prioritize position/color pairs instead of just positions
- tune priority function constants
	- automatically with genetic algorithm?
- nurikabe reachable, track whether groups are fulfilled. fulfilled groups can't reach beyond their group
- branch separation and persistence
  . build a list of spaces that the branch depends on
  . if a conclusion is made that doesn't affect the branch, don't restart the branch
- branch-merge 
  . when paired (black / white) solution branches reach common conclusions, it must be true
- branch-substitution
  . when one branch of a pair reaches a solution, and the other branch has already concluded things, those then apply to the parent branch, and it isn't necessary to derive them again
- instead of copying whole board, create an overlay dictionary which only has the values of changed cells
	- possibly use dict.update() to propagate changes
- perhaps track positions that may duplicate each other, and detect transitions where 2 threads get to the same board

tritower:
- custom priority function

slither link
- board should be ignorant of adjacency

compact format:
-3--
-0-2
1-3-
-1-1

full format:
+.+-+.+-+
. |3| | |
+-+.+-+.+
| .0. .2|
+.+.+-+-+
|1. |3. .
+.+.+-+.+
| .1. |1.
+-+-+-+.+
 
